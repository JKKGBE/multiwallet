package main

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"github.com/OpenBazaar/golang-socketio"
	"github.com/OpenBazaar/multiwallet/client"
	"github.com/OpenBazaar/multiwallet/client/transport"
	laddr "github.com/OpenBazaar/multiwallet/litecoin/address"
	zaddr "github.com/OpenBazaar/multiwallet/zcash/address"
	wi "github.com/OpenBazaar/wallet-interface"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/txscript"
	"github.com/btcsuite/btcutil"
	"github.com/cpacia/bchutil"
	"log"
	"net/http"
	"strconv"
	"sync"
	"time"
)

const SatoshisPerCoin = 100000000

// MockInsightServer is a dummy server which implements the insight API. It could be
// thought of as operating in regtest mode as you are able to tell it to generate blocks.
// It will validate utxo existence and value but will not validate the signature on transactions.
type MockInsightServer struct {
	// utxoSet is a map a serialized outpoint <hash:index> to the value of the utxo
	utxoSet map[string]uint64

	// addrIndex maps addresses to a list of transactions
	addrIndex map[string][]client.Transaction

	// utxoIndex maps addresses to a list of utxos
	utxoIndex map[string][]client.Utxo

	// cointype is the coin this server is purpoting to serve
	cointype wi.CoinType

	// lastBlock holds the last block generated by the server
	lastBlock client.Block

	// socketServer is the socketio server instance
	socketServer *gosocketio.Server

	// mtx is our lock for state changes
	mtx sync.RWMutex
}

// NewMockInsightServer instantiates and returns a new MockInsightServer
func NewMockInsightServer(coinType wi.CoinType) *MockInsightServer {

	m := &MockInsightServer{
		utxoSet:   make(map[string]uint64),
		addrIndex: make(map[string][]client.Transaction),
		utxoIndex: make(map[string][]client.Utxo),
		lastBlock: client.Block{
			Hash:              chaincfg.RegressionNetParams.GenesisBlock.BlockHash().String(),
			Height:            1,
			PreviousBlockhash: chainhash.Hash{}.String(),
		},
		socketServer: gosocketio.NewServer(transport.GetDefaultWebsocketTransport(nil)),
		mtx:          sync.RWMutex{},
	}
	//handle connected
	m.socketServer.On(gosocketio.OnConnection, func(c *gosocketio.Channel) {
		log.Println("New client connected")
	})

	m.socketServer.On("subscribe", func(c *gosocketio.Channel, msg interface{}) {
		c.Join("subscribe")
	})

	return m
}

// handleGetBestBlock is the handler for the /blocks endpoint
func (m *MockInsightServer) handleGetBestBlock(w http.ResponseWriter, r *http.Request) {
	m.mtx.Lock()
	defer m.mtx.Unlock()
	blocks := []client.Block{
		m.lastBlock,
		{
			Hash:   m.lastBlock.PreviousBlockhash,
			Height: m.lastBlock.Height - 1,
		},
	}
	bl := &client.BlockList{
		Blocks: blocks,
		Length: 2,
	}
	ret, err := json.MarshalIndent(&bl, "", "    ")
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	fmt.Fprint(w, string(ret))
}

// handleGenerate is a handler for an API call that will programatically generate
// the given number of blocks.
func (m *MockInsightServer) handleGenerate(w http.ResponseWriter, r *http.Request) {
	nBlocks := r.URL.Query().Get("nBlocks")
	n, err := strconv.Atoi(nBlocks)
	if err != nil {
		return
	}
	for i := 0; i < n; i++ {
		m.mtx.Lock()
		nextHash := make([]byte, 32)
		rand.Read(nextHash)
		block := client.Block{
			Height:            m.lastBlock.Height + 1,
			PreviousBlockhash: m.lastBlock.Hash,
			Hash:              hex.EncodeToString(nextHash),
		}
		m.lastBlock = block
		m.socketServer.BroadcastTo("subscribe", "bitcoind/hashblock", nil)
		m.mtx.Unlock()
	}
}

// handleGenerateToAddress is a handler for an API call which generates a new block and sends
// coins to the given address.
func (m *MockInsightServer) handleGenerateToAddress(w http.ResponseWriter, r *http.Request) {
	addr := r.URL.Query().Get("addr")
	amountStr := r.URL.Query().Get("amount")
	amt, err := strconv.Atoi(amountStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	outScript, err := m.payToAddrScript(addr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	m.mtx.Lock()
	defer m.mtx.Unlock()

	nextHash := make([]byte, 32)
	rand.Read(nextHash)
	block := client.Block{
		Height:            m.lastBlock.Height + 1,
		PreviousBlockhash: m.lastBlock.Hash,
		Hash:              hex.EncodeToString(nextHash),
	}
	m.lastBlock = block
	m.socketServer.BroadcastTo("subscribe", "bitcoind/hashblock", nil)

	txid := make([]byte, 32)
	rand.Read(txid)
	utxo := client.Utxo{
		Address:       addr,
		Amount:        float64(amt),
		AmountIface:   float64(amt),
		Confirmations: 1,
		Satoshis:      int64(amt * SatoshisPerCoin),
		ScriptPubKey:  hex.EncodeToString(outScript),
		Txid:          hex.EncodeToString(txid),
		Vout:          0,
	}

	utxos := m.utxoIndex[addr]
	utxos = append(utxos, utxo)
	m.utxoIndex[addr] = utxos

	m.utxoSet[hex.EncodeToString(txid)+":0"] = uint64(amt)

	tx := client.Transaction{
		Txid:          hex.EncodeToString(txid),
		Confirmations: 1,
		BlockHash:     block.Hash,
		BlockHeight:   block.Height,
		Time:          time.Now().Unix(),
		Version:       1,
		BlockTime:     time.Now().Unix(),
		Inputs: []client.Input{
			{
				Txid: chainhash.Hash{}.String(),
			},
		},
		Outputs: []client.Output{
			{
				Value:      float64(amt),
				ValueIface: float64(amt),
				N:          0,
				ScriptPubKey: client.OutScript{
					Addresses: []string{addr},
					Script: client.Script{
						Hex: hex.EncodeToString(outScript),
					},
				},
			},
		},
	}
	txs := m.addrIndex[addr]
	txs = append(txs, tx)
	m.addrIndex[addr] = txs

	out, err := json.MarshalIndent(&tx, "", "    ")
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	m.socketServer.BroadcastTo("subscribe", addr, string(out))
}

func (m *MockInsightServer) payToAddrScript(addrStr string) ([]byte, error) {
	var script []byte
	var err error
	switch m.cointype {
	case wi.Bitcoin:
		addr, err := btcutil.DecodeAddress(addrStr, &chaincfg.RegressionNetParams)
		if err != nil {
			return script, err
		}
		script, err = txscript.PayToAddrScript(addr)
	case wi.BitcoinCash:
		addr, err := bchutil.DecodeAddress(addrStr, &chaincfg.RegressionNetParams)
		if err != nil {
			return script, err
		}
		script, err = bchutil.PayToAddrScript(addr)
	case wi.Litecoin:
		addr, err := laddr.DecodeAddress(addrStr, &chaincfg.RegressionNetParams)
		if err != nil {
			return script, err
		}
		script, err = laddr.PayToAddrScript(addr)
	case wi.Zcash:
		addr, err := laddr.DecodeAddress(addrStr, &chaincfg.RegressionNetParams)
		if err != nil {
			return script, err
		}
		script, err = zaddr.PayToAddrScript(addr)
	}
	return script, err
}
